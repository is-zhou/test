# 本地项目管理工具

技术栈是 Vue3+Electron

一般情况和直接写 vue3 差不多，主要就是 Electron 和前端页面通信吧
`import {ipcMain, ipcRenderer} from "electron"`

Electron 可以通过 ipcMain.on 或者 ipcMain.send 去监听消息或者发送消息，前端通过 ipcRenderer.on 和 ipcRenderer.send 来监听发送消息

然后亮点可能是通过`抽象语法树AST`来实现路由文件及其他文件的更新

```ts
import parser from "@babel/parser"; // 解析代码文件为Ast
import traverse from "@babel/traverse"; // 遍历Ast
import template from "@babel/template"; //转换成Ast结构
import generator from "@babel/generator"; //将Ast再转成字代码字符串
```

```ts
import parser from "@babel/parser";
import traverse from "@babel/traverse";
import generator from "@babel/generator";
import template from "@babel/template";

import { readFileSync } from "fs-extra";
import { routeType } from "../utils/generateCodeString";
import { ArrayExpression } from "@babel/types";
import { formatOptions } from "../config";

export function updateRouterFileByAst(
  routerFilePath: string,
  newAllViewRoutes: routeType[],
  newDefaultImportList: { name: string; value: string }[]
) {
  let routerContent = "";

  try {
    routerContent = readFileSync(routerFilePath, "utf-8");
  } catch (error) {}

  if (!routerContent) {
    console.error("未找到 routerFilePath ");
    return undefined;
  }

  // 解析代码为 AST
  const ast = parser.parse(routerContent, {
    sourceType: "module",
    plugins: ["typescript"], // 可根据项目需要启用插件
  });

  // 提取的 routes ast节点
  let astRoutes: ArrayExpression | null = null;

  // 提取的 路由path 数组
  let existingPathRoutes: string[] = [];
  // 提取的 默认导入名称 数组
  let existingDefaultImportNames: Array<string> = [];

  // 遍历 AST 查找
  traverse(ast, {
    CallExpression(path) {
      if (
        path.node.callee.type === "Identifier" &&
        path.node.callee.name === "createRouter"
      ) {
        // 查找 createRouter({ history, routes, ... }) 的参数
        const configObject = path.node.arguments[0];
        if (configObject && configObject.type === "ObjectExpression") {
          const routesProperty = configObject.properties.find(
            (prop) =>
              prop.type === "ObjectProperty" &&
              prop.key.type === "Identifier" &&
              prop.key.name === "routes" &&
              prop.value.type === "ArrayExpression"
          );
          if (
            routesProperty &&
            routesProperty.type === "ObjectProperty" &&
            routesProperty.value.type === "ArrayExpression"
          ) {
            astRoutes = routesProperty.value;
          }
        }
      }
    },
    ImportDeclaration(path) {
      const configObject = path.node.specifiers[0];
      if (configObject && configObject.type === "ImportDefaultSpecifier") {
        if (
          !newAllViewRoutes
            .map((i) => i.component)
            .includes(configObject.local.name)
        ) {
          path.remove();
        } else {
          existingDefaultImportNames.push(configObject.local.name);
        }
      }
    },
  });

  // 检查是否找到 routes 数组
  if (!astRoutes || astRoutes === null) {
    console.error("未找到 routes 数组");
    return undefined;
  }
  // 提取现有路由的路径
  existingPathRoutes = (astRoutes as ArrayExpression).elements
    .map((route) => {
      if (route && route.type === "ObjectExpression") {
        const pathProp = route.properties.find((prop) => {
          if (
            prop &&
            prop.type === "ObjectProperty" &&
            prop.key.type === "Identifier"
          ) {
            return prop.key.name === "path";
          }
          return false;
        });
        return pathProp &&
          pathProp.type === "ObjectProperty" &&
          pathProp.value.type === "StringLiteral"
          ? pathProp.value.value
          : null;
      }
      return null;
    })
    .filter(Boolean) as string[];

  // 打印现有路由
  // console.log('现有路由:', existingPathRoutes);
  // console.log('现有导入:', existingDefaultImportNames);

  //找到要添加的默认导入
  const newImports = newDefaultImportList.filter(
    (i) => !existingDefaultImportNames.includes(i.name)
  );

  // 找到需要新增和删除的路由
  const newRoutes = newAllViewRoutes.filter(
    (route) => !existingPathRoutes.includes(route.path)
  );
  const removedRoutes = existingPathRoutes.filter(
    (path: string) => !newAllViewRoutes.map((i) => i.path).includes(path)
  );

  // 添加新路由
  newRoutes.forEach((route) => {
    const newRouteNode = parser.parseExpression(`
        {
            path: '${route.path}',
            name: '${route.name}',
            component: ${route.component},
            meta: {
                title: "",
            },
        }
    `);
    astRoutes?.elements.push(newRouteNode);
  });

  // 移除不存在的路由
  (astRoutes as ArrayExpression).elements = (
    astRoutes as ArrayExpression
  ).elements.filter((route) => {
    if (route && route.type === "ObjectExpression") {
      const pathProp = route.properties.find((prop) => {
        if (
          prop &&
          prop.type === "ObjectProperty" &&
          prop.key.type === "Identifier"
        ) {
          return prop.key.name === "path";
        }
        return false;
      });
      return !removedRoutes.includes(
        pathProp &&
          pathProp.type === "ObjectProperty" &&
          pathProp.value.type === "StringLiteral"
          ? pathProp.value.value
          : ""
      );
    }
  });

  newImports.forEach((i) => {
    const newImportDeclaration = template.ast(
      `import ${i.name} from "${i.value}";`
    );
    // 如果 newImportDeclaration 是数组，则取第一个元素
    const singleStatement = Array.isArray(newImportDeclaration)
      ? newImportDeclaration[0]
      : newImportDeclaration;

    ast.program.body.unshift(singleStatement);
  });

  // 生成更新后的代码
  const updatedCode = generator(ast, formatOptions).code;

  return updatedCode;
}
```
