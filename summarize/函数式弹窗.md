# 函数式弹窗

技术栈： Vue3 + TS

## 1、通过 SFC 单文件组件形式写好弹窗

关键点是声明 `emits`和`props`；这两个值后面会用作调用函数的参数类型推导，`props`是函数参数，`emits`的 reject 推导为返回值类型

```vue
<template></template>
<script setup lang="ts">
//调用弹窗的返回值类型
interface IEmits {
  (e: "close", isClose: "resolve" | "reject", result?: string): void;
}
//调用弹窗的参数类型
interface IProps {
  htmlMsg: string;
}

const emits = defineEmits<IEmits>();
const props = defineProps<IProps>();

async function handleConfirm() {
  emits("close", "resolve");
}
async function handleCancel() {
  emits("close", "reject");
}
</script>
<style lang="scss" scoped></style>
```

## 2、导出弹窗组件

使用 `defineAsyncComponent` 异步导出，这样打包时每个弹窗组件会形成一个单独的 chunk 模块，在真正调用的时候才会加载对应的组件（是否算项目优化？）

```ts
import { defineAsyncComponent } from "vue";

const dialogComponent = {
  DialogInfo: defineAsyncComponent(() => import("./DialogInfo.vue")),
  DialogSuccess: defineAsyncComponent(() => import("./DialogSuccess.vue")),
};

export default dialogComponent;
```

## 3、弹窗的 TS 类型推导

通过`keyof typeof` 将上面导出的`dialogComponent`所有组件的策略对象 key 转换为联合类型
`export type ModalName = keyof typeof modals;`

这样就获得了所有声明的弹窗组件的名称联合类型了`type ModalName = "DialogInfo" | "DialogSuccess"`

通过 `in` 关键字做类型的映射，即可以限制 ModalsProps 和 ModalsResult 类型的 key 的值。

### ModalsProps

`InstanceType<(typeof modals)[K]>`
`InstanceType<T>`：如果 T 是一个构造函数类型，`InstanceType<T>` 会得到其实例类型。对于 Vue 组件，这能得到组件实例类型（组件实例通常包含 `$props`、`$emit`、`$el` 等成员）。

`extends { $props: infer P } ? ... : never`
这是一个条件类型：如果该实例类型有 `$props` 属性，就把 `$props` 的类型推断出来`（infer P）`；否则结果是 `never`。
也就是说，我们依赖组件实例上存在 `$props` 来获得该组件的 `props` 类型

`Omit<P, keyof VNodeProps | keyof AllowedComponentProps | "onClose">`
把推断出来的 P（组件 props）中排除三个集合的 keys：

`keyof VNodeProps`：Vue 的 VNode 通用 props（如 key、ref 等）

`keyof AllowedComponentProps`：Vue 允许的组件通用 prop

字面 `"onClose"`：显式排除 onClose prop（通常是因为模态框的关闭不希望用户直接通过 prop 传递，或在外部控制时用事件而非 prop）
这样得到的就是“我们关心的、且不是 Vue 通用项且不是 onClose 的业务 props”。

`-readonly [V in keyof ...]: P[V];`
这是 TypeScript 的映射修饰符：-readonly 会去掉原来 props 上的 readonly 修饰符（如果 P 中某些属性是 readonly，映射后会变成可写）。
最终结果是一个对象类型，属性与 P（去除那些不想要的键）相同，且属性可写，并且类型为原来 P[V]。

### ModalsResult

这个类型定义在做另一件事：为每个 modal 推断出当模态框触发 close 事件时，close 事件携带的结果类型（即外部关心的“模态框返回值”类型）。逐步拆解：

外层同样是映射：`[K in ModalName]`。

`InstanceType<(typeof modals)[K]> extends { $emit: infer P }`
试图从组件实例类型上推断 $emit 的类型（Vue 组件实例通常有 $emit 方法，用来触发事件）。如果存在 $emit，就把它的函数类型用 infer P 取出来。

`P extends (event: infer E, ...args: infer A) => void`
假设 $emit 的类型是一个函数，其第一个参数是事件名 E（字符串字面量通常），其余参数是 ...args（组成一个元组 A）。通过 infer E 和 infer A 从 $emit 类型中推断事件名与参数元组。

注意：这是依赖于 $emit 被声明为类似 (event: 'close' | 'ok', ...args: [any, ...]) => void 的签名，这样 TypeScript 才能把 E 推断为具体字面量。

`? E extends "close" ? A[1] : never`
检查推断出的 E 是否包含 "close"。如果包含 "close"，就返回 A[1]（注意是元组 A 的第二个元素）；否则返回 never。
也就是说：对 close 事件，类型系统取 $emit 的参数元组的第二项作为该 modal 的“结果类型”。

其余 : never 分支同前：如果无法推断到 $emit 或其形状不符合预期，则该 modal 的结果类型为 never。

为什么是 A[1]（第二个参数）？

P 是 $emit 的类型，形如 (event, ...args) => void。A 表示 ...args 这一段的元组类型。通常习惯上 $emit('close', ctx, result) 或 $emit('close', null, result) 这种写法会把结果放在第二个位置（第一个是事件类型本身被单独捕获为 E，...args 的第一个元素索引是 0，第二个是 1）。

因为这段代码选择了 A[1]，它假定发出的 close 事件的参数结构是像 ($eventName, something, result) 这样，或者在类型上 ...args 的第二项是我们想要的“返回数据”。（具体为什么是 [1] 要看你们组件实际的 $emit('close', ...) 约定 — 如果你们是 $emit('close', result)，那么这里应为 A[0]。）

如果 $emit 的定义是不同的（例如 $emit('close', result)），那么 A[1] 会变成 undefined 或 never，所以这个类型的正确性依赖于组件里 $emit('close', ..., result) 的实际参数约定。

```ts
// types/modals.ts
import type modals from "./components";
import type { AllowedComponentProps, VNodeProps } from "vue";
export type ModalName = keyof typeof modals;

export type ModalsProps = {
  [K in ModalName]: InstanceType<(typeof modals)[K]> extends { $props: infer P }
    ? {
        -readonly [V in keyof Omit<
          P,
          keyof VNodeProps | keyof AllowedComponentProps | "onClose"
        >]: P[V];
      }
    : never;
};

export type ModalsResult = {
  [K in ModalName]: InstanceType<(typeof modals)[K]> extends { $emit: infer P }
    ? P extends (event: infer E, ...args: infer A) => void
      ? E extends "close"
        ? A[1]
        : never
      : never
    : never;
};
```

## 3、调用弹窗的函数

`createVNode(component, props)`：创建虚拟节点。

`render(vnode, container)`：将虚拟节点渲染到真实 DOM 中。

`dialogComponent` 所有组件策略对象
`ModalsProps / ModalsResult`：你前面定义的类型映射表，用于约束每个组件的 props 与返回值类型。

`TComponentName`：提取组件名称类型（"DialogInfo" | "DialogSuccess"）。

`const showCustomDialog = <T extends TComponentName>(
  componentName: T,
  props: ModalsProps[T]
): Promise<ModalsResult[T]> => {`
定义一个泛型函数 showCustomDialog。T 是组件名（DialogInfo 等）；props 会被自动推断为该组件对应的 props 类型；返回一个 Promise<ModalsResult[T]>，表示关闭弹窗后返回的结果类型。

```ts
import { createVNode, render, type VNode } from "vue";
import dialogComponent from "./components/index";
import type { ModalsProps, ModalsResult } from "./type";
type TComponentName = keyof typeof dialogComponent;

let vm: VNode | null = null;
let domContainer: HTMLDivElement;

const showCustomDialog = <T extends TComponentName>(
  componentName: T,
  props: ModalsProps[T]
): Promise<ModalsResult[T]> => {
  vm !== null && destroyedVm();

  domContainer = document.createElement("div");
  document.body.appendChild(domContainer);
  const component = dialogComponent[componentName];

  return new Promise((res, rej) => {
    vm = createVNode(component, {
      ...props,
      onClose: (closeType: "resolve" | "reject", result: ModalsResult[T]) => {
        if (closeType === "resolve") {
          res(result);
        } else if (closeType === "reject") {
          rej(result);
        }
        destroyedVm();
      },
    });
    render(vm, domContainer);
    window.addEventListener("popstate", destroyedVm, false);
  });
};
const destroyedVm = () => {
  document.body.removeChild(domContainer);
  vm = null;
  window.removeEventListener("popstate", destroyedVm);
};

export default showCustomDialog;
```

## 作为难点亮点表单话术

💡 亮点描述（简历版）

封装了一个类型安全的全局弹窗管理器，实现动态创建与销毁对话框组件的机制。
基于 createVNode 与 render 动态挂载组件实例，通过泛型自动推导组件的入参与返回结果类型，统一对话框调用方式（如 showCustomDialog('DialogInfo', props)），支持异步 Promise 风格结果处理与资源自动释放。该设计有效降低了重复弹窗逻辑、增强了可维护性与类型安全性。

🗣 面试讲述版（自然表达）

在项目中我封装了一个通用的弹窗调用机制。
我们有很多业务弹窗，每个都要单独引入和手动控制显示状态，维护成本很高。
我就封装了一个 showCustomDialog 方法，通过组件名动态加载对应弹窗组件，用 createVNode 和 render 动态挂载到 DOM。
调用时像这样：

`showCustomDialog('DialogInfo', { title: '提示' })
.then(res => { /_ 用户确认逻辑 _/ })
.catch(() => { /_ 用户取消逻辑 _/ });`

整个函数返回 Promise，支持异步等待关闭结果。
同时我结合 TypeScript 泛型，自动推导每个弹窗的 props 和返回类型，确保类型安全。
另外我还做了自动销毁和 popstate 监听，防止内存泄漏。
整体让弹窗逻辑从“手动管理”变成了“声明式调用”，显著提升了代码复用性和可维护性。
